#summary Erklärungen zur Arbeitsweise des Frontends

= Einleitung=
Das Frontend besteht aus zwei Teilen. Einer normalen Anzeige und einer für mobile Geräte. Beides sind verschiedene Views. 

In dieser Dokumentation ist längst nicht alles erklärt, dafür gibt es viele Kommentare im Quellcode. Hier gibt es einen Überblick über das Programm und besondere Knackpunkte. 

<wiki:toc max_depth="3" />

= Das Standardfrontend =
== Viewcontroller und Template==
Das Standardfrontend besteht aus dem Viewcontroller (`views/verplan/view.html.php`), der Templatedatei (`views/verplan/tmpl/default.php`), und einigen zusätzlichen Dateien (`includes`). Da das Frontend mit Ajax arbeitet, werden die Daten (außer einmal am Anfang) über eine URL nachgeladen. Die Daten gelangen über die [Verplan_API] in das Frontend. 

Bei der Datei `view.html.php` handelt es sich um eine Datei, in der eine Klasse existiert, welche GET Paramter einliest (vor allem wichtig, wenn js deaktiviert) und die Daten, die das Frontend benötigt (Einstellungen usw) bereitstellt. 
Die Datei `tmpl/default.php` enthält das Template für das View. Das Tempalte sorgt für die HTML Ausgabe und lädt auch die benötigten Javascripte und Stylesheets (über /inc/scripts.inc.php). Die Scripte liegen in `includes/js` und die Stylesheets und `includes/css`. 

== Javascript ==
Das Fronetnd arbeitet mit sehr viel Javascript, wobei ich zum größten Teil das Javascriptframework [http://jquery.com/ jQuery] verwendet habe. Eine gute Dokumentation gibt es hier: [http://docs.jquery.com/]. 

Die Hauptdatei ist die Datei `general.js`. Diese enthält die Initialisierung und viele kleine Hilfsfunktionen (z.B. für den Hash). 

=== Tableplugins ===
Ganz am Anfang werden die jQuery Tabellen Plugins initialisiert (`table_init()`). Das ist wichtig, weil alle Plugins (auch wenn sie geladen wurden) noch einmal auf die Tabelle angewendet werden müssen. Falls sich etwas an der Tabelle ändert, müssen einige Plugins erneut angewendet werden oder eine bestimmte Funktion aufgerufen werden. Dies kann gesammelt mit `table_update()` durchgeführt werden (z.B. nach einem Ajax Request und dem Ändern der Tabellendaten). 

=== Sortieren ===
Zum Sortieren der Tabelle habe ich das Plugin [http://tablesorter.com/docs/ Tablesorter 2.0] verwendet. Damit auch Klassen (welche ein Format haben, welches normalerweise falsch sortiert wird) richtig sortiert werden, habe ich einen neuen Parser geschrieben. 

=== Ajax ===
Das Programm verwendet das [http://www.mikage.to/jquery/jquery_history.html jQuery History Plugin], um trotz Ajaxfunktionalitäten noch ein Vor- und Zurückspringen zu ermöglichen (Browserhistory). 

Aus diesem Grund findest du in der Datei `general.js` folgenden Code
{{{
jQuery.historyInit(loadverplan,'index.php');
}}}
Hier wird die Browserhistory initialisiert und die Funktion `loadverplan()` aufgerufen, welche für die Verarbeitung des Hashwertes verantwortlich ist. Die Funktion `loadverplan()` wird immer aufgerufen, wenn entweder Vor und Zurück gesprungen oder die Funktion `jQuery.historyLoad(hash);` aufgerufen wird. 

Der Ajaxaufruf, welcher auf die [Verplan_API Verplan API] zurückgreift, befindet sich in der Datei `ajaxjson.js`. Die Effekte, die sich von und nach einem Ajaxrequest durchgeführt werden, findest du in der Datei `ajaxeffects`.

Der Aufruf der Daten (die als json vorliegen), geschieht mit

{{{
jQuery.ajax( {
	type : "GET",
	dataType : "json",
	url : rooturl + "index.php",
	data : 'option=com_verplan&view=verplan&format=js&date=' + ajax_date
			+ '&stand=' + ajax_stand + '&options=' + ajax_options,
	timeout: (4 * 1000),
	async : true,
	global : true,
	success : function(XMLHttpRequest, textStatus) {
		if (XMLHttpRequest.infos == '') {
			JSONfail(XMLHttpRequest, textStatus);
		} else {
			JSONsuccess(XMLHttpRequest, textStatus);
		}
	},
	error : function(XMLHttpRequest, textStatus, errorThrown) {
		if (errorThrown) {
			alert('XMLHttpRequest:'+XMLHttpRequest+'\n'+'textStatus: '+textStatus+'\n'+"Error: " +errorThrown);
		}
	},
	complete: ajaxcomplete		
});
}}}

Nachdem die Daten erfolgreich geladen wurden, werden sie an `JSONsuccess()` weitergegeben. Hier werden die Daten ausgewertet. Falls eine Tabelle angezeigt werden soll, wird dies mit `buildTableFromJSON()` erledigt. Falls ein Link zum Vertretungsplan (oder ein Hinweis, dass es keinen gibt) angezeigt werden soll, wird das direkt in der Funktion erledigt. 

Die Auswahl des Vorgehens passiert mit einer Switch Anweiseung

{{{
switch (json.infos[length].type) {
case 'db':
	//Datenbank
	break;
case 'none':
        //kein plan
	break;
default:
        //eine datei
	break;
}
}}}

=== Notification System ===
==== own ====
Es ist möglich eigene Benachrichtigungen anzuzeigen. Dazu gibt es in der Datei `general.js` die Funktionen `showHint()` und `hideHint()`. Um eine Nachricht erst nach einer gerade noch angezeigt anzuzeigen sollte man ein Intervall starten, welches wartet, bis eine Nachricht ausgeblendet ist. Ein Bsp kann so aussehen:
{{{
clearInterval(myInterval2);

console.log('start listener');
myInterval2 = setInterval(function() {
	console.log('wait for hint');
	if (hintshown == false) {
		clearInterval(myInterval2);
		hintshown == true;
		setTimeout("showHint('Fehler. Es existiert kein Plan für das gewählte Datum.', 'warn', '400px', 'noplan');", 200);
	}
},100);
}}}

==== pnotify ====
[http://pines.svn.sourceforge.net/viewvc/pines/sandbox/notify/notify.html Pnotify] ist ein jQuery Notification System, welches viele Möglichkeiten bietet und stabil läuft. Mit diesem System ist es viel einfacher, mehrere Nachrichten zusammen anzuzeigen. Leider verbraucht es viel Platz und verdeckt andere Elemente. Damit ist es für viele Webseiten ungeeignet. 

=== Filter ===
In den erweiterten Optionen gibt es die Möglichkeit, die Tabelle zu filtern. Die erste Möglichkeit sollte selbst klärend sein. Bei dem Filter handelt es sich um einen Livefilter, der nicht extra bestätigt werden muss. Das entsprechend Plugin heißt [http://gregweber.info/projects/uitablefilter uiTablefilter]. 

Die Möglichkeit eine Klasse direkt zu filtern hat ein paar Eigenheiten. Die Liste mit den Klassen wird nach einem Ajax Request erzeugt. Wenn eine Klasse ausgewählt wird, wird sie in das Filterfeld darüber übertragen und dann wird erst gefiltert. Das hat den Vorteil, dass nur ein richtiges Filtersystem genutzt wird und der User verstehen kann, welche Möglichkeiten das Filterfeld bietet. 

Es gibt die Möglichkeit das Filtereingabefeld direkt zu leeren. Dazu habe ich das Plugin [http://github.com/ono/clearable_text_field clearableTextField] genutzt.

=== Die Dateien ".js.php" ===
Um Daten (z.B. Einstellungen) von PHP nach JS zu bekommen, habe ich einige Extradateien geschrieben, die die Endung `js.php` haben. 

== Das Design ==
Das gesamte Template ist so gestaltet, dass es jQueryUI kompatibel ist und alle [http://jqueryui.com/themeroller/#themeGallery jQueryUI Themes] verwendet werden können. Es ist "Themeswitcherkompatibel".

= Das Frontend für mobile Geräte =
Diese Seite wird mit dem Parameter `view=mobile` aufgerufen und ist für mobile Endgeräte optimiert. Diese Seite hat keine Ajaxfunktionalitäten und arbeitet nur mit PHP. Diese Seite arbeitet genauso, wie die normale Anzeige, eignet sich also sehr gut, um zu verstehen, wie die Seite arbeitet, wenn JS deaktiviert ist. 